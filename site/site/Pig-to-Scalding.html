<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
  <meta http-equiv="Content-Style-Type" content="text/css"></meta>
  <meta name="generator" content="pandoc"></meta>
  <title>Pig to Scalding</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; }
code &gt; span.dt { color: #902000; }
code &gt; span.dv { color: #40a070; }
code &gt; span.bn { color: #40a070; }
code &gt; span.fl { color: #40a070; }
code &gt; span.ch { color: #4070a0; }
code &gt; span.st { color: #4070a0; }
code &gt; span.co { color: #60a0b0; font-style: italic; }
code &gt; span.ot { color: #007020; }
code &gt; span.al { color: #ff0000; font-weight: bold; }
code &gt; span.fu { color: #06287e; }
code &gt; span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="http://localhost:8000/_src/css/bootstrap.min.css" type="text/css"></link>
  <link rel="stylesheet" href="http://localhost:8000/_src/css/custom.css" type="text/css"></link>
</head>
<body>

<div class="row">
    <div class="container">
        <div class="col-xs-4">
            <img id="logo" src="http://localhost:8000//_src/scalding.png">
        </div>
    </div>
</div>

<div class="container">
<div class="row">

<div class="col-xs-3" role="navigation" id="nav-left">
<ul class="nav nav-pills nav-stacked">
    <li role="presentation"><a href="http://localhost:8000/site/.Foo.md.html">.Foo</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/11.html">11</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/_Sidebar.html">_Sidebar</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/API-Reference.html">API-Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Calling-Scalding-from-inside-your-application.html">Calling-Scalding-from-inside-your-application</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Common-Exceptions-and-possible-reasons.html">Common-Exceptions-and-possible-reasons</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Comparison-to-Scrunch-and-Scoobi.html">Comparison-to-Scrunch-and-Scoobi</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Field-rules.html">Field-rules</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Fields-API:-reduce-functions-of-GroupBuilder.html">Fields-API:-reduce-functions-of-GroupBuilder</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Fields-based-API-Reference.html">Fields-based-API-Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Frequently-asked-questions.html">Frequently-asked-questions</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/hello.html">hello</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Home.html">Home</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Introduction-to-Matrix-Library.html">Introduction-to-Matrix-Library</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Matrix-API-Reference.html">Matrix-API-Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Pig-to-Scalding.html">Pig-to-Scalding</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Powered-By.html">Powered-By</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/REPL-Reference.html">REPL-Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Rosetta-Code.html">Rosetta-Code</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Run-in-Intellij-IDEA.html">Run-in-Intellij-IDEA</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scala-and-sbt-for-Homebrew-users.html">Scala-and-sbt-for-Homebrew-users</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scala-and-sbt-for-MacPorts-users.html">Scala-and-sbt-for-MacPorts-users</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scald.rb.html">Scald</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-Commons.html">Scalding-Commons</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-HBase.html">Scalding-HBase</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-on-amazon-elastic-mapreduce.html">Scalding-on-amazon-elastic-mapreduce</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-REPL.html">Scalding-REPL</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-Sources.html">Scalding-Sources</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-with-CDH3U2-in-a-Maven-project.html">Scalding-with-CDH3U2-in-a-Maven-project</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Aggregation-using-Algebird-Aggregators.html">Aggregation-using-Algebird-Aggregators</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Alice-in-Wonderland.html">Alice-in-Wonderland</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Building-bigger-platforms-with-scalding.html">Building-bigger-platforms-with-scalding</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Getting-Started.html">Getting-Started</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Intro-to-Scalding-Jobs.html">Intro-to-Scalding-Jobs</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/SQL-to-Scalding.html">SQL-to-Scalding</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Type-safe-api-reference.html">Type-safe-api-reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Upgrading-to-0.9.0.html">Upgrading-to-0</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Using-scalding-with-other-versions-of-scala.html">Using-scalding-with-other-versions-of-scala</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Using-the-distributed-cache.html">Using-the-distributed-cache</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Why-pack-unpack-and-not--toList[].html">Why-pack-unpack-and-not--toList[]</a>
    </li>
    <li role="presentation" class="active"><a href="#">Pig to Scalding</a></li>
</ul>
</div>

<div class="col-xs-9 text-body">

<div id="header">
<h1 class="title">Pig to Scalding</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#load">LOAD</a></li>
<li><a href="#store">STORE</a></li>
<li><a href="#foreach">FOREACH</a></li>
<li><a href="#filter">FILTER</a></li>
<li><a href="#foreach-a-generate-flatten...">FOREACH A GENERATE FLATTEN(...)</a></li>
<li><a href="#aggregating">Aggregating</a></li>
<li><a href="#join">Join</a></li>
<li><a href="#scala-cheat-sheet">Scala cheat sheet:</a><ul>
<li><a href="#primitive-types">Primitive types:</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#common-types">Common types:</a></li>
<li><a href="#pattern-matching">pattern matching:</a></li>
<li><a href="#typed-pipes-basics">Typed pipes basics</a></li>
</ul></li>
</ul>
</div>
<p>This pages intends to help Pig users to learn Scalding by listing corresponding statements and basic Scala knowledge. You should also take a look at the <a href="https://github.com/twitter/scalding/blob/develop/tutorial/TypedTutorial.scala">tutorial</a>.</p>
<h3 id="load">LOAD</h3>
<p>Pig:</p>
<pre><code>A = LOAD 'foo'</code></pre>
<p>Scalding:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// The TextLine source splits the input by lines.</span>
<span class="kw">val</span> textSource = <span class="fu">TextLine</span>(<span class="fu">args</span>(<span class="st">&quot;input&quot;</span>))
<span class="co">// Create a type-safe pipe from the TextLine.</span>
<span class="kw">val</span> lines: TypedPipe[String] = TypedPipe.<span class="fu">from</span>[String](textSource)</code></pre>
<h3 id="store">STORE</h3>
<p>Pig:</p>
<pre><code>STORE B INTO 'bar'</code></pre>
<p>Scalding:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">b.<span class="fu">write</span>(TypedTsv[String](<span class="fu">args</span>(<span class="st">&quot;output&quot;</span>)))</code></pre>
<h3 id="foreach">FOREACH</h3>
<p>Pig:</p>
<pre><code>B = FOREACH A GENERATE /* expression */</code></pre>
<p>Scalding:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> b = a.<span class="fu">map</span>((t) =&gt; <span class="co">/* expression */</span>)</code></pre>
<h3 id="filter">FILTER</h3>
<p>Pig:</p>
<pre><code>B = FILTER A BY foo == 0</code></pre>
<p>Scalding:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">a.<span class="fu">filter</span>{ <span class="kw">case</span> (foo, bar) =&gt; foo == <span class="dv">0</span> } <span class="co">// using pattern matching to name elements of a tuple</span>
<span class="co">// if you don't need to name an element you can use the _ wildcard instead</span>
a.<span class="fu">filter</span>{ <span class="kw">case</span> (foo, _) =&gt; foo == <span class="dv">0</span> }</code></pre>
<h3 id="foreach-a-generate-flatten...">FOREACH A GENERATE FLATTEN(...)</h3>
<p>in Scalding the use of flatMap is similar to the following in Pig:</p>
<pre><code>B = FOREACH A GENERATE FLATTEN(Tokenize(text))</code></pre>
<p>in Scalding:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">tokenize</span>(s: String) = s.<span class="fu">split</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">s+&quot;</span>).<span class="fu">toList</span>
b = a.<span class="fu">flatMap</span>(<span class="fu">tokenize</span>(_))
<span class="co">// which produces the same result as:</span>
b = a.<span class="fu">map</span>(<span class="fu">tokenize</span>(_)).<span class="fu">flatten</span>()
<span class="co">// and the same as</span>
b = a.<span class="fu">map</span>(<span class="fu">tokenize</span>(_)).<span class="fu">flatten</span> <span class="co">// empty parens are usually omitted</span></code></pre>
<h3 id="aggregating">Aggregating</h3>
<p>Pig:</p>
<pre><code>B = FOREACH (GROUP A BY $0) GENERATE COUNT(A)</code></pre>
<p>Scalding:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> b = a.<span class="fu">groupBy</span>(_.<span class="fu">_1</span>).<span class="fu">size</span></code></pre>
<p>notice the _ shorthand used here.</p>
<h3 id="join">Join</h3>
<p>Pig:</p>
<pre><code>C = JOIN A BY $0, B BY $0</code></pre>
<p>Scalding: assuming a and b are both a Pipe[(K,V)], you can join them as follows</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> c = a.<span class="fu">join</span>(b)</code></pre>
<h2 id="scala-cheat-sheet">Scala cheat sheet:</h2>
<p>It is recommended to know the basics of Scala when trying out Scalding. Here are some common things Scala noobs may become confused about coming from Java and Pig.</p>
<h3 id="primitive-types">Primitive types:</h3>
<p>Scala uses the java primitive type names but with the first letter capitalized. (Scala uses the boxed type automatically when needed.) ex: Java:</p>
<pre><code>final int a = 1</code></pre>
<p>Scala:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> a = <span class="dv">1</span>  <span class="co">// (val means it's a constant. Type is inferred. use var for variables)</span>
<span class="kw">val</span> a: Int = <span class="dv">1</span> <span class="co">// same thing with explicit type declaration</span></code></pre>
<h3 id="functions">Functions</h3>
<pre><code>def f(x:Int) = x * 2 // return type inferred

def f(x:Int): Int = x * 2 // same thing with explicit return type</code></pre>
<h3 id="common-types">Common types:</h3>
<h4 id="case-classes">case classes</h4>
<p>Immutable data class that can be used in pattern matching ex: <code>scala case class User(val firstname: String, val lastname: String)</code>scala kind of similar to the following in Java plus the added benefit of pattern matching:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">class</span> User {
   public <span class="kw">final</span> String firstname; <span class="co">// those are immutable so it's fine to make them public</span>
   public <span class="kw">final</span> String lastname;
   public <span class="fu">User</span>(String firstname,String lastname) {
     <span class="kw">this</span>.<span class="fu">firstname</span> = firstname;
     <span class="kw">this</span>.<span class="fu">lastname</span> = lastname;
  }
}</code></pre>
<h4 id="tuples">Tuples</h4>
<p>fixed size with type assigned to each field ex:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> t = (<span class="dv">1</span>, <span class="st">&quot;foo&quot;</span>) <span class="co">// the type of t is Tuple2[Int, String]</span>
t.<span class="fu">_1</span> <span class="co">// =&gt; 1</span>
t.<span class="fu">_2</span> <span class="co">// =&gt; &quot;foo&quot;</span></code></pre>
<p>assigning the members of t to a and b:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> (a, b) = t
a <span class="co">// =&gt; 1</span>
b <span class="co">// =&gt; 2</span></code></pre>
<p>it is the same as:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> a = t.<span class="fu">_1</span>
<span class="kw">val</span> b = t.<span class="fu">_2</span></code></pre>
<p>it is <em>not</em> the same as:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> a, b = t
<span class="co">// which is:</span>
<span class="kw">val</span> a = t
<span class="kw">val</span> b = t</code></pre>
<h3 id="pattern-matching">pattern matching:</h3>
<p>example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">t <span class="kw">match</span> {
  <span class="kw">case</span> (a, b) =&gt; a
}</code></pre>
<p>Which translate to: if t is a <code>Tuple2</code>, assign t._1 to a and t._2 to b and return a You don't need to name things you don't use. The <code>_</code> wildcard can be used:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">t <span class="kw">match</span> {
  <span class="kw">case</span> (a, _) =&gt; a
}</code></pre>
<p>similarly with case classes:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> u = <span class="fu">User</span>(<span class="st">&quot;Jack&quot;</span>, <span class="st">&quot;Jackson&quot;</span>) <span class="co">// This is the same as User.apply(&quot;Jack&quot;, &quot;Jackson&quot;). Not a constructor call</span>
<span class="kw">var</span> v = u <span class="kw">match</span> {
  <span class="kw">case</span> <span class="fu">User</span>(firstname, lastname) =&gt; firstname
  ... <span class="co">// other cases</span>
}</code></pre>
<p>More advanced pattern matching</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Name(first: String, middle: String, last: String)
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Address</span>(street: String, zip: String, city: String)
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(name: Name, age: Int, address: Address)
<span class="kw">val</span> p = <span class="fu">Person</span>(Name(<span class="st">&quot;Bob&quot;</span>, <span class="st">&quot;E.&quot;</span>, <span class="st">&quot;Roberts&quot;</span>), <span class="dv">42</span>, <span class="fu">Address</span>(<span class="st">&quot;23 colorado st.&quot;</span>, <span class="st">&quot;99999&quot;</span>, <span class="st">&quot;Las Vegas&quot;</span>))
<span class="co">// unwrap Person</span>
p <span class="kw">match</span>  { <span class="kw">case</span> <span class="fu">Person</span>(a,b,c) =&gt; (a,b,c) }
<span class="co">// unwrap Person and Name</span>
p <span class="kw">match</span>  { <span class="kw">case</span> <span class="fu">Person</span>(Name(f,m,l), b, c) =&gt; (f, m, l, b, c) }
<span class="co">// multiple case statements (anonymizing minors not in the &quot;Roberts&quot; familly)</span>
p <span class="kw">match</span>  {
  <span class="kw">case</span> <span class="fu">Person</span>(Name(first, _,<span class="st">&quot;Roberts&quot;</span>), _, _) =&gt; first <span class="co">// matches only when lastname in Name is &quot;Roberts&quot;</span>
  <span class="kw">case</span> <span class="fu">Person</span>(Name(first, _, _), age, _) <span class="kw">if</span> (age &gt; <span class="dv">21</span>) =&gt; first <span class="co">// predicate can be applied as well</span>
  <span class="kw">case</span> _ =&gt; <span class="st">&quot;anonymous&quot;</span> <span class="co">// default case if none of the above applies</span>
}
<span class="co">// just extracting age</span>
p <span class="kw">match</span>  { <span class="kw">case</span> <span class="fu">Person</span>(_, age, _) =&gt; age }
<span class="co">// this one could be</span>
p.<span class="fu">age</span>
<span class="co">// flattening the entire structure</span>
p <span class="kw">match</span>  { <span class="kw">case</span> <span class="fu">Person</span>(Name(f,m,l), age, <span class="fu">Address</span>(street, zip, city)) =&gt; (f, m, l, age, street, zip, city) }</code></pre>
<h3 id="typed-pipes-basics">Typed pipes basics</h3>
<h4 id="map">map</h4>
<p>If we have the following p1 of typed <code>Pipe[T]</code> f of type <code>Function1[T,U]</code> then</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> p2 = p1.<span class="fu">map</span>(f)</code></pre>
<p>p2 is of type <code>Pipe[U]</code></p>
<h4 id="lambda-syntax">lambda syntax</h4>
<p>When defining a function inline we use the following syntax:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">(param1, param2, ...) =&gt; <span class="co">/* expression */</span></code></pre>
<p>which can be used in map</p>
<pre class="sourceCode scala"><code class="sourceCode scala">p.<span class="fu">map</span>( (a) =&gt; a + <span class="dv">1</span> )</code></pre>
<p>Here we are defining a function that takes one parameter named <code>a</code> and apply it to all elements of p</p>
<h4 id="map-variations">map variations</h4>
<p>with p1 of type <code>Pipe[(Int, String)]</code> (a Pipe of Tuple2[Int, String]) mapping elements in p1:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">p1.<span class="fu">map</span>( (t) =&gt; t.<span class="fu">_1</span> )</code></pre>
<p>When a function takes only one parameter <em>and</em> is extremely simple, we can use the following shorthand:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">p1.<span class="fu">map</span>( _.<span class="fu">_1</span> )</code></pre>
<p>This syntax defines a function that takes one parameter on which we call ._1 (get the first element of the tuple)</p>
<p>WARNING: _ expands only to the expression directly around it. _._1._2 works but (_._1)._2 does not. (it turns into ((t) =&gt; (t._1))._2 which does not compile) always fallback to the full syntax when in doubt: (t) =&gt; (t._1)._2 works</p>
<p>In Scala the syntax for getting a field is the same as for calling a parameter-less method (parens are omitted). In fact getting a fields is calling a parameter-less methods.</p>
<h4 id="operator-notation-to-call-a-function">operator notation to call a function:</h4>
<pre class="sourceCode scala"><code class="sourceCode scala"> p1 map f</code></pre>
<p>is the same as</p>
<pre class="sourceCode scala"><code class="sourceCode scala"> p1.<span class="fu">map</span>(f)</code></pre>
<p>In Scala every method can be used as an operator. In fact, this is how operators are implemented as symbols are allowed in method names.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">p1 filter { _.<span class="fu">_1</span> == <span class="dv">0</span> } map { _.<span class="fu">_2</span> }</code></pre>
<p>also:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">p1.<span class="fu">map</span> { (t) =&gt; t.<span class="fu">_1</span> }</code></pre>
<p>notice the curly braces, we're executing a block of code that returns a function. the result (last statement) of { } is passed to map</p>
<pre class="sourceCode scala"><code class="sourceCode scala">p1.<span class="fu">map</span> { <span class="fu">println</span>(<span class="st">&quot;foo&quot;</span>); (t) =&gt; t.<span class="fu">_1</span> }</code></pre>
<p>&quot;foo&quot; is printed once (before passing the function to map)</p>
<pre class="sourceCode scala"><code class="sourceCode scala">p1.<span class="fu">map</span> { <span class="fu">println</span>(<span class="st">&quot;foo&quot;</span>); _.<span class="fu">_1</span> }</code></pre>
<p>&quot;foo&quot; is printed once (before passing the function to map)</p>
<pre class="sourceCode scala"><code class="sourceCode scala">l.<span class="fu">map</span>{ (t) =&gt; { <span class="fu">println</span>(<span class="st">&quot;foo&quot;</span>); t.<span class="fu">_1</span> } }</code></pre>
<p>&quot;foo&quot; is printed for each element</p>
<h4 id="pattern-matching-short-hand">pattern matching short hand</h4>
<pre class="sourceCode scala"><code class="sourceCode scala">p1.<span class="fu">map</span> { <span class="kw">case</span> (a,b) =&gt; a }</code></pre>
<p>block of code that returns a partial function that is then passed to map is a short hand for:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">p1.<span class="fu">map</span>( (t) =&gt; t <span class="kw">match</span> { <span class="kw">case</span> (a,b) =&gt; a } )</code></pre>

</div>

</div>
</div>

</body>
</html>

