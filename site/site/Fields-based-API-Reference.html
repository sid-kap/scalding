<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
  <meta http-equiv="Content-Style-Type" content="text/css"></meta>
  <meta name="generator" content="pandoc"></meta>
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code &gt; span.kw { color: #007020; font-weight: bold; }
code &gt; span.dt { color: #902000; }
code &gt; span.dv { color: #40a070; }
code &gt; span.bn { color: #40a070; }
code &gt; span.fl { color: #40a070; }
code &gt; span.ch { color: #4070a0; }
code &gt; span.st { color: #4070a0; }
code &gt; span.co { color: #60a0b0; font-style: italic; }
code &gt; span.ot { color: #007020; }
code &gt; span.al { color: #ff0000; font-weight: bold; }
code &gt; span.fu { color: #06287e; }
code &gt; span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="http://localhost:8000/_src/css/bootstrap.min.css" type="text/css"></link>
  <link rel="stylesheet" href="http://localhost:8000/_src/css/custom.css" type="text/css"></link>
</head>
<body>

<div class="row">
    <div class="container">
        <div class="col-xs-4">
            <img id="logo" src="http://localhost:8000//_src/scalding.png">
        </div>
    </div>
</div>

<div class="container">
<div class="row">

<div class="col-xs-3" role="navigation" id="nav-left">
<ul class="nav nav-pills nav-stacked">
    <li role="presentation"><a href="http://localhost:8000/site/.Foo.md.html">.Foo</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/11.html">11</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/_Sidebar.html">_Sidebar</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/API-Reference.html">API-Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Calling-Scalding-from-inside-your-application.html">Calling-Scalding-from-inside-your-application</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Common-Exceptions-and-possible-reasons.html">Common-Exceptions-and-possible-reasons</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Comparison-to-Scrunch-and-Scoobi.html">Comparison-to-Scrunch-and-Scoobi</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Field-rules.html">Field-rules</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Fields-API:-reduce-functions-of-GroupBuilder.html">Fields-API:-reduce-functions-of-GroupBuilder</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Fields-based-API-Reference.html">Fields-based-API-Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Frequently-asked-questions.html">Frequently-asked-questions</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/hello.html">hello</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Home.html">Home</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Introduction-to-Matrix-Library.html">Introduction-to-Matrix-Library</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Matrix-API-Reference.html">Matrix-API-Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Pig-to-Scalding.html">Pig-to-Scalding</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Powered-By.html">Powered-By</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/REPL-Reference.html">REPL-Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Rosetta-Code.html">Rosetta-Code</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Run-in-Intellij-IDEA.html">Run-in-Intellij-IDEA</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scala-and-sbt-for-Homebrew-users.html">Scala-and-sbt-for-Homebrew-users</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scala-and-sbt-for-MacPorts-users.html">Scala-and-sbt-for-MacPorts-users</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scald.rb.html">Scald</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-Commons.html">Scalding-Commons</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-HBase.html">Scalding-HBase</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-on-amazon-elastic-mapreduce.html">Scalding-on-amazon-elastic-mapreduce</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-REPL.html">Scalding-REPL</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-Sources.html">Scalding-Sources</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Scalding-with-CDH3U2-in-a-Maven-project.html">Scalding-with-CDH3U2-in-a-Maven-project</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Aggregation-using-Algebird-Aggregators.html">Aggregation-using-Algebird-Aggregators</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Alice-in-Wonderland.html">Alice-in-Wonderland</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Building-bigger-platforms-with-scalding.html">Building-bigger-platforms-with-scalding</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Getting-Started.html">Getting-Started</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/Intro-to-Scalding-Jobs.html">Intro-to-Scalding-Jobs</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Tutorials/SQL-to-Scalding.html">SQL-to-Scalding</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Type-safe-api-reference.html">Type-safe-api-reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Upgrading-to-0.9.0.html">Upgrading-to-0</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Using-scalding-with-other-versions-of-scala.html">Using-scalding-with-other-versions-of-scala</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Using-the-distributed-cache.html">Using-the-distributed-cache</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Why-pack-unpack-and-not--toList[].html">Why-pack-unpack-and-not--toList[]</a>
    </li>
    <li role="presentation" class="active"><a href="#"></a></li>
</ul>
</div>

<div class="col-xs-9 text-body">

<div id="TOC">
<ul>
<li><a href="#map-like-functions"><a name="map-functions" href="#wiki-map-functions"> <b>Map-like</b> functions</a></a></li>
<li><a href="#grouping-functions"><a name="grouping-functions" href="#wiki-grouping-functions"> <b>Grouping</b> functions</a></a></li>
<li><a href="#groupreduce-operations"><a name="group-operations" href="#wiki-group-operations"> <b>Group/Reduce Operations</b></a></a></li>
<li><a href="#join-operations"><a name="join-functions" href="#wiki-join-functions"> <b>Join</b> operations</a></a></li>
<li><a href="#joins">joins</a></li>
<li><a href="#join-modes">join modes</a></li>
<li><a href="#miscellaneous-functions"><a name="misc-functions" href="#wiki-misc-functions"> <b>Miscellaneous</b> functions</a></a></li>
<li><a href="#about-functions-on-multiple-fields-at-once"><a name="notes-tuples" href="#wiki-notes-tuples">About functions on multiple fields at once</a></a></li>
</ul>
</div>
<p>Scalding functions can be divided into four types:</p>
<ul>
<li><a href="#wiki-map-functions"><b>Map-like</b> functions</a></li>
<li><a href="#wiki-grouping-functions"><b>Grouping</b> functions</a></li>
<li><a href="#wiki-group-operations"><b>Group/Reduce</b> operations</a></li>
<li><a href="#wiki-join-functions"><b>Join</b> operations</a></li>
</ul>
<p><a href="#wiki-misc-functions"><b>Miscellaneous </b> functions</a></p>
<p><a href="#wiki-notes-tuples">About functions on multiple fields at once</a></p>
<h3 id="map-like-functions"><a name="map-functions" href="#wiki-map-functions"> <b>Map-like</b> functions</a></h3>
<p>Map-like functions operate over individual rows in a pipe, usually transforming them in some way. They are defined in <a href="https://github.com/twitter/scalding/blob/develop/scalding-core/src/main/scala/com/twitter/scalding/RichPipe.scala"><code>RichPipe.scala</code></a>.</p>
<h4 id="map-flatmap-mapto-flatmapto">map, flatMap, mapTo, flatMapTo</h4>
<p><a name="map" href="#wiki-map">#</a> pipe.<b>map</b>(<i>existingFields</i> -&gt; <i>additionalFields</i>){<i>function</i>}</p>
<p>Adds new fields that are transformations of existing ones.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// In addition to the existing `speed` field, the new `fasterBirds`</span>
<span class="co">// pipe will contain a new `doubledSpeed` field (plus any other </span>
<span class="co">// fields that `birds` already contained).</span>
<span class="kw">val</span> fasterBirds = birds.<span class="fu">map</span>('speed -&gt; 'doubledSpeed) { speed : Int =&gt; speed * <span class="dv">2</span> }</code></pre>
<p>You can also map from and to multiple fields at once.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> britishBirds =
  birds.<span class="fu">map</span>(('weightInLbs, 'heightInFt) -&gt; ('weightInKg, 'heightInMeters)) {
    x : (Float, Float) =&gt;
    <span class="kw">val</span> (weightInLbs, heightInFt) = x
    (<span class="fl">0.454</span> * weightInLbs, <span class="fl">0.305</span> * heightInFt)
  }</code></pre>
<p>You can map from a field to itself to update its value:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  items.<span class="fu">map</span>('price -&gt; 'price) { price : Float =&gt; price * <span class="fl">1.1</span> }</code></pre>
<p>You can use <code>'*</code> (here and elsewhere) to mean all fields.</p>
<p><a name="flatMap" href="#wiki-flatMap">#</a> pipe.<b>flatMap</b>(<i>existingFields</i> -&gt; <i>additionalFields</i>){<i>function</i>}</p>
<p>Maps each element to a list (or an <code>Option</code>), and then flattens that list (emits a Cascading Tuple per each item in the returned list).</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> words =
  books.<span class="fu">flatMap</span>('text -&gt; 'word) { text : String =&gt; text.<span class="fu">split</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">s+&quot;</span>) }</code></pre>
<p><a name="mapTo" href="#wiki-mapTo">#</a> pipe.<b>mapTo</b>(<i>existingFields</i> -&gt; <i>additionalFields</i>){<i>function</i>}</p>
<p>MapTo is equivalent to mapping and then projecting to the new fields, but is more efficient. Thus, the following two lines produce the same result:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">pipe.<span class="fu">mapTo</span>(existingFields -&gt; additionalFields){ ... }
pipe.<span class="fu">map</span>(existingFields -&gt; additionalFields){ ... }.<span class="fu">project</span>(additionalFields)</code></pre>
<p>Here is another example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> savings =
  items.<span class="fu">mapTo</span>(('price, 'discountedPrice) -&gt; 'savings) {
    x : (Float, Float) =&gt;
    <span class="kw">val</span> (price, discountedPrice) = x
    price - discountedPrice
  }</code></pre>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> savingsSame =
  items
    .<span class="fu">map</span>(('price, 'discountedPrice) -&gt; 'savings) {
      x : (Float, Float) =&gt;
      <span class="kw">val</span> (price, discountedPrice) = x
      price - discountedPrice
    }
    .<span class="fu">project</span>('savings)</code></pre>
<p><a name="flatMapTo" href="#wiki-flatMapTo">#</a> pipe.<b>flatMapTo</b>(<i>existingFields</i> -&gt; <i>additionalFields</i>){<i>function</i>}</p>
<p>The <code>flatMap</code> analogue of <code>mapTo</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> words =
  books.<span class="fu">flatMapTo</span>('text -&gt; 'word) { text : String =&gt; text.<span class="fu">split</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">s+&quot;</span>) }</code></pre>
<h4 id="project-discard">project, discard</h4>
<p><a name="project" href="#wiki-project">#</a> pipe.<b>project</b>(<i>fields</i>)</p>
<p>Remove all unspecified fields.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// The new pipe contains only two fields: `jobTitle` and `salary`.</span>
<span class="kw">val</span> onlyKeepWorkInfo = people.<span class="fu">project</span>('jobTitle, 'salary)</code></pre>
<p><a name="discard" href="#wiki-discard">#</a> pipe.<b>discard</b>(<i>fields</i>)</p>
<p>Removes specified fields. <code>discard</code> is the opposite of <code>project</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> forgetBirth = people.<span class="fu">discard</span>('birthplace, 'birthday)</code></pre>
<h4 id="insert-rename-limit">insert, rename, limit</h4>
<p><a name="insert" href="#wiki-insert">#</a> pipe.<b>insert</b>(<i>field</i>, <i>value</i>) Insert field(s) with constant value(s)</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  items.<span class="fu">insert</span>(('inflation, 'collegeCostInflation), (<span class="fl">0.02</span>, <span class="fl">0.10</span>))</code></pre>
<p><a name="rename" href="#wiki-rename">#</a> pipe.<b>rename</b>(<i>fields</i> -&gt; <i>fields</i>) Rename fields</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  items.<span class="fu">rename</span>(('x, 'y) -&gt; ('X, 'Y))</code></pre>
<p><a name="limit" href="#wiki-limit">#</a> pipe.<b>limit</b>(<i>number</i>)</p>
<p>Allows only a fixed number of items to pass in a pipe.</p>
<h4 id="filter-filternot">filter, filterNot</h4>
<p><a name="filter" href="#wiki-filter">#</a> pipe.<b>filter</b>(<i>fields</i>){<i>function</i>}</p>
<p>Filters out rows for which function is false.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> birds = animals.<span class="fu">filter</span>('type) { <span class="kw">type</span> : String =&gt; <span class="kw">type</span> == <span class="st">&quot;bird&quot;</span> }</code></pre>
<p>You can also filter over multiple fields at once.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> fastAndTallBirds =
  birds.<span class="fu">filter</span>('speed, 'height) { 
    fields : (Float, Float) =&gt;
    <span class="kw">val</span> (speed, height) = fields
    (speed &gt; <span class="dv">100</span>) &amp;&amp; (height &gt; <span class="dv">100</span>)
  }</code></pre>
<p><a name="filterNot" href="#wiki-filterNot">#</a> pipe.<b>filterNot</b>(<i>fields</i>){<i>function</i>}</p>
<p>Works exactly like a negated <code>filter</code> operation. It will filter out the rows for which the predicate function returns <code>true</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> notBirds = animals.<span class="fu">filterNot</span>('type) { <span class="kw">type</span> : String =&gt; <span class="kw">type</span> == <span class="st">&quot;bird&quot;</span> }</code></pre>
<h4 id="unique">unique</h4>
<p><a name="unique" href="#wiki-unique">#</a> pipe.<b>unique</b>(<i>fields</i>)</p>
<p>Keeps only unique rows based on a specified set of fields.</p>
<p>This looks like a mapping function, but it actually requires a map-reduce pair, so doing this during one of your <code>groupBy</code> operations (if you can structure your algorithm to simultaneously do so) will save work.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Keep only the unique (firstName, lastName) pairs. All other fields are discarded.</span>
people.<span class="fu">unique</span>('firstName, 'lastName)</code></pre>
<h4 id="pack-unpack">pack, unpack</h4>
<p><a name="pack" href="#wiki-pack">#</a> pipe.<b>pack</b>(<i>Type</i>)(<i>fields</i> -&gt; <i>object</i>)</p>
<p>You can pack multiple fields into a single object, by using Java reflection. For now this only works for objects that have a default constructor that takes no arguments. The Java reflection only happens once for each field, so the performance should be very good. Basically, the pack and unpack functions are used to group or ungroup fields, respectively, by using Objects.</p>
<p>For example suppose that you have a class called <code>Person</code>, with fields <code>age</code> and <code>height</code>, and setters <code>setAge</code> and <code>setHeight</code>. Then you can do the following to populate those fields:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> people = data.<span class="fu">pack</span>[Person](('age, 'height) -&gt; 'person)</code></pre>
<p><a name="unpack" href="#wiki-unpack">#</a> pipe.<b>unpack</b>(<i>Type</i>)(<i>object</i> -&gt; <i>fields</i>)</p>
<p>Conversely, you can unpack the contents of an object into multiple fields.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> data = people.<span class="fu">unpack</span>[Person]('person -&gt; ('age, 'height))</code></pre>
<p>The default reflection-based unpacker works for case classes as well as standard Thrift- and Protobuf-generated classes.</p>
<p>If you want to use tuple packing and unpacking for objects that do not depend on Java reflection, then you need to implement the <code>TuplePacker</code> and <code>TupleUnpacker</code> abstract classes and define implicit conversions in the context of your <code>Job</code> class. See <a href="https://github.com/twitter/scalding/blob/develop/scalding-core/src/main/scala/com/twitter/scalding/TuplePacker.scala"><code>TuplePacker.scala</code></a> for more.</p>
<h3 id="grouping-functions"><a name="grouping-functions" href="#wiki-grouping-functions"> <b>Grouping</b> functions</a></h3>
<p>Grouping/reducing functions operate over <i>groups</i> of rows in a pipe, often aggregating them in some way. They usually involve a reduce phase. These functions are defined in <a href="https://github.com/twitter/scalding/blob/develop/scalding-core/src/main/scala/com/twitter/scalding/GroupBuilder.scala"><code>GroupBuilder.scala</code></a>.</p>
<p>Most of these functions are inspired by the <a href="http://www.scala-lang.org/api/current/scala/collection/Iterable.html">scala.collection.Iterable</a> API.</p>
<h4 id="groupby-groupall-grouprandomly-shard">groupBy, groupAll, groupRandomly, shard</h4>
<p><a name="groupBy" href="#wiki-groupBy">#</a> pipe.<b>groupBy</b>(<i>fields</i>){ <i>group =&gt; ...</i> }</p>
<p>Groups your pipe by the values in the specified set of fields, and then applies a set of operations to the group to create a new set of fields. All the entries with the same value (in the field we are grouping by) are sent to the same reducer for processing. But, different values can be sent to different reducers.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Create a new pipe with (word, count) fields.</span>
<span class="kw">val</span> wordCounts = words.<span class="fu">groupBy</span>('word) { group =&gt; group.<span class="fu">size</span> }</code></pre>
<p>Group operations chain together.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Create a new pipe containing </span>
<span class="co">// (country, sex, # of people in country of sex, mean age sliced by country and sex).</span>
<span class="kw">val</span> demographics = people.<span class="fu">groupBy</span>('country, 'sex) { _.<span class="fu">size</span>.<span class="fu">average</span>('age) }</code></pre>
<p>When the field to group by is an enum or a thrift type, currently it won't work properly. Please avoid using enum type for group by.</p>
<p><a name="groupAll" href="#wiki-groupAll">#</a> pipe.<b>groupAll</b>{ <i>group =&gt; ...</i> }</p>
<p>Creates a single group consisting of the entire pipe.</p>
<p>Think three times before using this function on Hadoop. This removes the ability to do any parallelism in the reducers. That said, accumulating a global variable may require it. Tip: if you need to bring this value to another pipe, try <code>crossWithTiny</code> (another function you should use with great care).</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// vocabSize is now a pipe with a single entry, containing the total number of words in the vocabulary.</span>
<span class="kw">val</span> vocabSize = wordCounts.<span class="fu">groupAll</span> { _.<span class="fu">size</span> }</code></pre>
<p><code>groupAll</code> is also useful if you want to sort a pipe immediately before outputting it.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> sortedPeople = people.<span class="fu">groupAll</span> { _.<span class="fu">sortBy</span>('lastName, 'firstName) }</code></pre>
<p>As we mentioned earlier, groupBy splits the various groups among different reducers, which do not collaborate. Therefore, if we want to sort everything we use groupAll, which basically sends everything to 1 reducer (since it creates a single group of the entire pipe). Then, the sorting can happen on the reducer.</p>
<h3 id="groupreduce-operations"><a name="group-operations" href="#wiki-group-operations"> <b>Group/Reduce Operations</b></a></h3>
<p>These are implemented in <a href="http://twitter.github.io/scalding/#com.twitter.scalding.StreamOperations"><code>StreamOperations</code></a> <a href="https://github.com/twitter/scalding/blob/master/scalding-core/src/main/scala/com/twitter/scalding/StreamOperations.scala">src</a>, [<code>FoldOperations</code>] (http://twitter.github.io/scalding/#com.twitter.scalding.FoldOperations) <a href="https://github.com/twitter/scalding/blob/master/scalding-core/src/main/scala/com/twitter/scalding/FoldOperations.scala">src</a>, [<code>ReduceOperations</code>] (http://twitter.github.io/scalding/#com.twitter.scalding.ReduceOperations) <a href="https://github.com/twitter/scalding/blob/master/scalding-core/src/main/scala/com/twitter/scalding/ReduceOperations.scala">src</a></p>
<p>Here is an overview of some of the most popular:</p>
<p><a name="size" href="#wiki-size">#</a> group.<b>size</b>(<i>name</i>)</p>
<p>Counts the number of rows in this group. By default, the name of the new field is <code>size</code>, but you can pass in a new name as well.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// The new `wordCounts` pipe contains &quot;word&quot; and &quot;size&quot; fields.</span>
<span class="kw">val</span> wordCounts = words.<span class="fu">groupBy</span>('word) { _.<span class="fu">size</span> }

<span class="co">// Same, but calls the new field &quot;count&quot; instead of the default &quot;size&quot;.</span>
<span class="kw">val</span> wordCounts = words.<span class="fu">groupBy</span>('word) { _.<span class="fu">size</span>('count) }</code></pre>
<p><a name="average" href="#wiki-average">#</a> group.<b>average</b>(<i>field</i>)</p>
<p>Computes the mean over a field. By default, the new field has the same name as the original field, but you can pass in a new name as well.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Find the mean age of boys vs. girls. The new pipe contains &quot;sex&quot; and &quot;age&quot; fields.</span>
<span class="kw">val</span> demographics = people.<span class="fu">groupBy</span>('sex) { _.<span class="fu">average</span>('age) }

<span class="co">// Same, but call the new field &quot;meanAge&quot;.</span>
<span class="kw">val</span> demographics = people.<span class="fu">groupBy</span>('sex) { _.<span class="fu">average</span>('age -&gt; 'meanAge) }</code></pre>
<p><a name="sizeAveStdev" href="#wiki-sizeavestdev">#</a> group.<b>sizeAveStdev</b>(<i>field</i>, <i>fields</i>)</p>
<p>Computes the count, average and standard deviation over a field. You must pass new fields to accommodate the output data</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Find the count of boys vs. girls, their mean age and standard deviation. </span>
<span class="co">// The new pipe contains &quot;sex&quot;, &quot;count&quot;, &quot;meanAge&quot; and &quot;stdevAge&quot; fields.</span>
<span class="kw">val</span> demographics = people.<span class="fu">groupBy</span>('sex) { _.<span class="fu">sizeAveStdev</span>('age -&gt; ('count, 'meanAge, 'stdevAge) ) }</code></pre>
<p><a name="mkString" href="#wiki-mkString">#</a> group.<b>mkString</b>(<i>field</i>, <i>joiner</i>)</p>
<p>Turns a column in the group into a string. Again, the new field has the same name as the original field by default, but you can also pass in a new name.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Take all the words with a given count and join them with a comma.</span>
wordCounts.<span class="fu">groupBy</span>('count) { _.<span class="fu">mkString</span>('word, <span class="st">&quot;,&quot;</span>) }

<span class="co">// Same, but call the new column &quot;words&quot;.</span>
wordCounts.<span class="fu">groupBy</span>('count) { _.<span class="fu">mkString</span>('word -&gt; 'words, <span class="st">&quot;,&quot;</span>) }</code></pre>
<p><a name="toList" href="#wiki-toList">#</a> group.<b>toList</b>(<i>field</i>)</p>
<p>Turns a column in the group into a list. An idiosyncracy about this is that null items in the list are removed. It is equivalent to first filtering null items. Be careful about depending on this behavior as it may be changed before scalding 1.0.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Take all the words with this count and join them into a list.</span>
wordCounts.<span class="fu">groupBy</span>('count) { _.<span class="fu">toList</span>[String]('word) }

<span class="co">// Same, but call the new column &quot;words&quot;.</span>
wordCounts.<span class="fu">groupBy</span>('count) { _.<span class="fu">toList</span>[String]('word -&gt; 'words) }</code></pre>
<p><a name="sum" href="#wiki-sum">#</a> group.<b>sum</b>(<i>field</i>)</p>
<p>Sums over a column in the group.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">expenses.<span class="fu">groupBy</span>('shoppingLocation) { _.<span class="fu">sum</span>[Double]('cost) }

<span class="co">// Same, but call the summed column 'totalCost'.</span>
expenses.<span class="fu">groupBy</span>('shoppingLocation) { _.<span class="fu">sum</span>[Double]('cost -&gt; 'totalCost) }</code></pre>
<p><a name="max" href="#wiki-max">#</a> group.<b>max</b>(<i>field</i>), group.<b>min</b>(<i>field</i>)</p>
<p>Computes the largest or smallest element of a group.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">expenses.<span class="fu">groupBy</span>('shoppingLocation) { _.<span class="fu">max</span>('cost) }</code></pre>
<p><a name="count" href="#wiki-count">#</a> group.<b>count</b>(<i>field</i>){<i>function</i>}</p>
<p>Counts the number of rows in a group that satisfy some predicate.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> usersWithImpressions =
  users
    .<span class="fu">groupBy</span>('user) { _.<span class="fu">count</span>('numImpressions) { x : Long =&gt; x &gt; <span class="dv">0</span> } }</code></pre>
<p><a name="sortBy" href="#wiki-sortBy">#</a> group.<b>sortBy</b>(<i>fields</i>)</p>
<p>Using <strong>sortBy</strong> you can sort the output before writing it into some output sink.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">users.<span class="fu">groupAll</span> { _.<span class="fu">sortBy</span>('age) }</code></pre>
<p>Note: When reading from a CSV, the data types are set to String,hence the sorting will be alphabetically, therefore to sort by age, an int, you need to convert it to an integer. For example,</p>
<pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">val</span> users = <span class="fu">Csv</span>(file_source, separator = <span class="st">&quot;,&quot;</span>, fields = Schema)
    .<span class="fu">read</span>
    .<span class="fu">map</span> ('age-&gt; 'ageInt) {x:Int =&gt; x}
    .<span class="fu">groupAll</span> { _.<span class="fu">sortBy</span>('ageInt) } <span class="co">// will sort age as a number. </span></code></pre>
<p><a name="reverse" href="#wiki-reverse">#</a> group.sortBy(<i>fields</i>).<b>reverse</b></p>
<p>You can also <strong>reverse</strong> the sort-order used (descending, instead of ascending):</p>
<pre class="sourceCode scala"><code class="sourceCode scala">users.<span class="fu">groupAll</span> { _.<span class="fu">sortBy</span>('age).<span class="fu">reverse</span> }</code></pre>
<p>At the moment it is a limitation that <strong>reverse</strong> <em>must</em> be called after a <strong>sortBy</strong>, so this: <code>_.reverse.sortBy('age) /* wrong */</code> would compile, but would throw an &quot;Cannot sort when reducing&quot; exception during the planning phase.</p>
<h4 id="reduce-foldleft">reduce, foldLeft</h4>
<p><a name="reduce" href="#wiki-reduce">#</a> group.<b>reduce</b>(<i>field</i>){<i>function</i>}</p>
<p>Applies a reduce function over grouped columns. The reduce function is required to be associative, so that the work can be done on the map side and not solely on the reduce side (like a combiner).</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// This example is equivalent to using `sum`, but you can also supply other reduce functions.</span>
expenses.<span class="fu">groupBy</span>('shoppingLocation) {
    _.<span class="fu">reduce</span>('cost -&gt; 'totalCost) {
      (costSoFar : Double, cost : Double) =&gt; costSoFar + cost
    }
  }</code></pre>
<p><a name="foldLeft" href="#wiki-foldLeft">#</a> group.<b>foldLeft</b>(<i>field</i>){<i>function</i>}</p>
<p>Like reduce, but all the work happens on the reduce side (so the fold function is not required to be associative, and can in fact output a type different from what it takes in). Fold is the fundamental reduce function.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// for the sake of example, assume we want to discount cost so far by specified amounts</span>
<span class="co">// and that items are in the order we want</span>
expenses.<span class="fu">groupBy</span>('shoppingLocation) {
 <span class="kw">val</span> init_cost_so_far = <span class="fl">0.0</span>
 _.<span class="fu">foldLeft</span>(('cost, 'inflation) -&gt; 'discountedCost)(init_cost_so_far) {
        (discountedCostSoFar: Long, cost_infl: (Double, Double)) =&gt;
        <span class="kw">val</span> (cost, inflation) = cost_infl
        discountedCostSoFar * inflation + cost
    }
  }</code></pre>
<h4 id="take-sorting">take &amp; sorting</h4>
<p><a name="take" href="#wiki-take">#</a> group.<b>take</b>(<i>number</i>)</p>
<p>take(n) keeps the first n elements of the group.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">groupBy</span>('shoppingLocation) {
 _.<span class="fu">take</span>(<span class="dv">100</span>)
}</code></pre>
<p><a name="takeWhile" href="#wiki-takeWhile">#</a> group.<b>takeWhile</b><a href="f%20:%20Fields">T</a>(fn : (T) =&gt; Boolean)</p>
<p>Take while the predicate is true; stop at the first false.</p>
<p><a name="drop" href="#wiki-drop">#</a> group.<b>drop</b>(<i>number</i>)</p>
<p>drop(n) drops the first n elements of the group.</p>
<p><a name="sortWithTake" href="#wiki-sortWithTake">#</a> group.<b>sortWithTake</b>(<i> fields -&gt; result_field, take_number</i>)</p>
<p>Equivalent to sorting by a comparison function, then taking k items. This is MUCH more efficient than doing a total sort followed by a take, since these bounded sorts are done on the mapper, so only a sort of size k is needed.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">sortWithTake</span>( ('clicks, 'tweet) -&gt; 'results, <span class="dv">5</span>) {
  comparison_function : ( clickTweet1 :(Long,Long), clickTweet2:(Long,Long) =&gt; 
  clickTweet1.<span class="fu">_1</span> &lt; clickTweet2.<span class="fu">_1</span> }</code></pre>
<p><a name="sortedReverseTake" href="#wiki-sortedReverseTake">#</a> group.<b>sortedReverseTake</b><a href="fields%20-&gt;%20temporary_field_tuple,%20number">Field Types</a> Reverse stands for decreasing order.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">//calculates top 50 cities and states by number of newborn count. </span>
<span class="kw">val</span> TopBirthPlaces=peoplePipe 
.<span class="fu">groupBy</span>('CityName, 'StateName) { _.<span class="fu">size</span>('CountNewBorns) }
.<span class="fu">groupAll</span> { _.<span class="fu">sortedReverseTake</span>[(Long, String,String)](( 'CountNewBorns, 'CityName,'StateName) -&gt; 'top, <span class="dv">50</span>) }
.<span class="fu">flattenTo</span>[(Long,String,String)]('top -&gt; ('CountNewBorns, 'CityName, 'StateName)) <span class="co">//flatenTo as oppose to just flatten to exclude the intermediate top tuple.  </span>
}</code></pre>
<p>In this example, we first sort by 'CountNewBorns, then by 'CityName and finally by'StateName. Since it is in decreasing order, the entry with most newborns will be the first one. All the fields are stored as a tuple in the 'top field, which we then flatten to get the original fields.</p>
<h4 id="reducers">reducers</h4>
<p><a name="reducers" href="#wiki-reducers">#</a> group.<b>reducers</b>(<i>number</i>)</p>
<p>Override the number of reducers used in the groupBy. Useful when outputting fewer files is desired.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">pipe.<span class="fu">groupBy</span>('key) {
    _.<span class="fu">sortBy</span>('count).<span class="fu">reverse</span>.<span class="fu">reducers</span>(<span class="dv">6</span>)
}</code></pre>
<h4 id="chained-group-operations">Chained group operations</h4>
<p>Chain together multiple GroupBuilder operations to apply different reductions to different fields:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">group.<span class="fu">sum</span>[Long]('x).<span class="fu">max</span>('y)</code></pre>
<h4 id="pivot-unpivot">pivot, unpivot</h4>
<p>Pivot and unpivot are similar to SQL and Excel functions that change data from a row-based representation to a column-based one (in the case of <code>pivot</code>) or vice-versa (in the case of <code>unpivot</code>).</p>
<p><a name="pivot" href="#wiki-pivot">#</a> group.<b>pivot</b></p>
<p>Converts data from a row-based representation to a column-based one.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">pipe.<span class="fu">groupBy</span>('key) { _.<span class="fu">pivot</span>(('col, 'val) -&gt; ('x, 'y, 'z)) }</code></pre>
<p>In the first example, you need to have rows like:</p>
<pre><code>3, &quot;x&quot;, 1.2
3, &quot;y&quot;, 3.4
4, &quot;z&quot;, 4</code></pre>
<p>and after the pivot you will have:</p>
<pre><code>3, 1.2, 3.4, null
4, null, null, 4</code></pre>
<p>When pivoting, you can provide an explicit default value instead of replacing missing rows with null:</p>
<pre class="sourceCode scala"><code class="sourceCode scala">pipe.<span class="fu">groupBy</span>('key) { _.<span class="fu">pivot</span>(('col, 'val) -&gt; ('x, 'y, 'z), <span class="fl">0.0</span>) }</code></pre>
<p>This will result in:</p>
<pre><code>3, 1.2, 3.4, 0.0
4, 0.0, 0.0, 4</code></pre>
<p><a name="unpivot" href="#wiki-unpivot">#</a> pipe.<b>unpivot</b></p>
<p>Converts data from a column-based representation to a row-based one. (Strictly speaking, <code>unpivot</code> is a map-like function which appears in RichPipe.scala and does not require a reduce-phase.)</p>
<pre class="sourceCode scala"><code class="sourceCode scala">pipe.<span class="fu">unpivot</span>(('x, 'y, 'z) -&gt; ('col, 'val))</code></pre>
<h3 id="join-operations"><a name="join-functions" href="#wiki-join-functions"> <b>Join</b> operations</a></h3>
<p>Join operations merge two pipes on a specified set of keys, similar to SQL joins. They are defined in <a href="https://github.com/twitter/scalding/blob/master/src/main/scala/com/twitter/scalding/JoinAlgorithms.scala"><code>JoinAlgorithms.scala</code></a>.</p>
<p>All the expected joining modes are present: inner, outer, left, and right. Cascading implements these as CoGroup operations which are implemented in a single map-reduce job.</p>
<h3 id="joins">joins</h3>
<p>Since it is important to hint at the relative sizes of your data, Scalding provides three main types of joins. All of them are inner joins:</p>
<ul>
<li><code>joinWithSmaller</code></li>
<li><code>joinWithLarger</code></li>
<li><code>joinWithTiny</code>: this is a special map-side join that does not move the left-hand side from mappers to reducers. Instead, the entire right hand side is replicated to the nodes holding the left side. By, &quot;right hand side,&quot; we mean the significantly smaller pipe that we are passing as an argument to this function.</li>
</ul>
<p>When in doubt, choose <code>joinWithSmaller</code> and optimize if that step seems to be taking a very long time.</p>
<p><a name="joinWithSmaller" href="#wiki-joinWithSmaller">#</a> pipe1.<b>joinWithSmaller</b>(<i>fields</i>, <i>pipe2</i>)</p>
<p>Joins two pipes on a specified set of fields. Use this when <code>pipe2</code> has fewer values per key than <code>pipe1</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// `people` is a pipe with a &quot;birthCityId&quot; field.</span>
<span class="co">// It is &quot;larger&quot; because there are many people and many share the same birthCityId</span>
<span class="co">// Join it against the `cities` pipe, which contains an &quot;id&quot; field.</span>
<span class="co">// Cities is &quot;smaller&quot; because it has a smaller number of values per id (in this case 1)</span>
<span class="kw">val</span> peopleWithBirthplaces = people.<span class="fu">joinWithSmaller</span>('birthCityId -&gt; 'id, cities)

<span class="co">// Join on both city.id and state.id</span>
<span class="kw">val</span> peopleWithBirthplaces = people.<span class="fu">joinWithSmaller</span>( ('birthCityId , 'birthStateID) -&gt; ('id,'StateID) , cities)</code></pre>
<p><a name="joinWithLarger" href="#wiki-joinWithLarger">#</a> pipe1.<b>joinWithLarger</b>(<i>fields</i>, <i>pipe2</i>)</p>
<p>Joins two pipes on a specified set of fields. Use this when <code>pipe2</code> has more values per key than <code>pipe1</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// `cities` is a pipe with an &quot;id&quot; field. </span>
<span class="co">// `cities` is &quot;smaller&quot; because it has a smaller number of values per id (in this case 1)</span>
<span class="co">// Join it against the `people` pipe, which contains a &quot;birthCityId&quot; field.</span>
<span class="co">// `people` is &quot;larger&quot; because there are many people and many share the same birthCityId</span>
<span class="kw">val</span> peopleWithBirthplaces = cities.<span class="fu">joinWithLarger</span>('id -&gt; 'birthCityId, people)</code></pre>
<p><a name="joinWithTiny" href="#wiki-joinWithTiny">#</a> pipe1.<b>joinWithTiny</b>(<i>fields</i>, <i>pipe2</i>)</p>
<p>Joins two pipes on a specified set of fields. As explained above, this is a special map-side join that does not move the left-hand side from mappers to reducers. Instead, the entire right hand side is replicated to the mappers (nodes) holding the left side. <code>joinWithTiny</code> is appropriate when you know that <code># of rows in bigger pipe &gt; mappers * # rows in smaller pipe</code>, where <code>mappers</code> is the number of mappers in the job.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// Assume this is a small pipe containing at most couple thousand rows.</span>
<span class="kw">val</span> celebrities = ...

<span class="kw">val</span> celebrityBirthplaces = cities.<span class="fu">joinWithTiny</span>('id -&gt; 'birthCityId, celebrities)</code></pre>
<h3 id="join-modes">join modes</h3>
<p>By default, all joins are inner joins. You can also specify that you want a <b>left join</b>, a <b>right join</b>, or an <b>outer join</b>. <b>left join</b>: It keeps all the rows/entries from the left pipe and attaches the entries that have matching keys from the right pipe. The entries of the left pipe that do not have any matches with the right pipe have <code>null</code> for the new fields introduced by the right pipe. <b>right join</b>: Similar to the left join; it keeps all the rows/entries from the right pipe. <b>outer join</b>: This join keeps all entries from both pipes. Again, if there is no match the empty fields contain <code>null</code>.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cascading.<span class="fu">pipe</span>.<span class="fu">joiner</span>.<span class="fu">_</span>

people.<span class="fu">joinWithSmaller</span>('birthCityId -&gt; 'id, cities, joiner = <span class="kw">new</span> LeftJoin)
people.<span class="fu">joinWithSmaller</span>('birthCityId -&gt; 'id, cities, joiner = <span class="kw">new</span> RightJoin)
people.<span class="fu">joinWithSmaller</span>('birthCityId -&gt; 'id, cities, joiner = <span class="kw">new</span> OuterJoin)</code></pre>
<p>Note that when performing an inner join, the left and right pipes are allowed to join on common field names.</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// This is allowed. Only a single &quot;ssn&quot; field will be left in the resulting merged pipe.</span>
people.<span class="fu">joinWithSmaller</span>('ssn -&gt; 'ssn, teachers)
<span class="co">// Instead</span>
people.<span class="fu">joinWithSmaller</span>('ssn_left -&gt; 'ssn_right, teachers)
<span class="co">// Both fields are kept after the join.</span></code></pre>
<p>However, joining on common field names is not allowed for the left joins, right joins, or outer joins (since it is useful to know whether a missing field value comes from the left pipe or the right pipe).</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="co">// This is not allowed.</span>
people.<span class="fu">joinWithSmaller</span>('ssn -&gt; 'ssn, teachers, joiner = <span class="kw">new</span> OuterJoin)</code></pre>
<h4 id="crosswithtiny">crossWithTiny</h4>
<p><a name="crossWithTiny" href="#wiki-crossWithTiny">#</a> pipe1.<b>crossWithTiny</b>(<i>pipe2</i>)</p>
<p>Performs the cross product of two pipes. The right (pipe2) is replicated to all the nodes, and the left is not moved at all. Therefore, the &quot;tiny&quot; part should be on the right.existingFields</p>
<h3 id="miscellaneous-functions"><a name="misc-functions" href="#wiki-misc-functions"> <b>Miscellaneous</b> functions</a></h3>
<h4 id="on-pipes">On pipes</h4>
<p>All this and more in <a href="https://github.com/twitter/scalding/blob/develop/scalding-core/src/main/scala/com/twitter/scalding/RichPipe.scala"><code>RichPipe.scala</code></a>: * <code>pipe1 ++ pipe2</code> to union two pipes that have the same fields * <code>p.addTrap</code> to capture any exceptions thrown on the pipe</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> peopleWithBirthplaces = people.<span class="fu">joinWithSmaller</span>('birthCityId -&gt; 'id, cities)
   .<span class="fu">addTrap</span>(<span class="fu">Tsv</span>(<span class="st">&quot;/home/data/error_folder/&quot;</span>))</code></pre>
<ul>
<li><code>p.debug</code> to see rows on stdout/stderr</li>
<li><code>p.name(&quot;myPipe&quot;)</code> to name your pipe</li>
<li><p><code>p.partition(fields_to_apply_function -&gt; field_based_on_function_output) {function} {group}</code> Given a function, it partitions the pipe into several groups based on the output of the function. Then applies a GroupBuilder function on each of the groups.</p>
<pre class="sourceCode scala"><code class="sourceCode scala">pipe.<span class="fu">mapTo</span>(()-&gt;('age, 'weight) { ... }
.<span class="fu">partition</span>('age -&gt; 'isAdult) { _ &gt; <span class="dv">18</span> } { _.<span class="fu">average</span>('weight) }
<span class="co">//pipe now contains the average weights of adults (above 18) and minors.</span></code></pre></li>
<li><code>p.sample(percentage)</code> where 0.00 &lt; percentage &lt; 1.00, note that percentage is actually a decimal</li>
<li><code>p.thenDo{ p : Pipe =&gt; if(scala.util.Random.nextInt(2) &gt; 0) p.insert('foo, 1) else p }</code></li>
<li><p><code>p.write(Tsv(&quot;myfile&quot;))</code></p></li>
</ul>
<h4 id="on-groups">On groups</h4>
<p>All this and more in <a href="https://github.com/twitter/scalding/blob/develop/scalding-core/src/main/scala/com/twitter/scalding/ReduceOperations.scala"><code>ReduceOperations.scala</code></a>: * <code>group.dot('a, 'b, 'a_dot_b)</code> dot product</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="fu">groupBy</span>('x) { _.<span class="fu">dot</span>('y,'z, 'ydotz) }
<span class="co">//First do &quot;times&quot; on each pair, then &quot;plus&quot; them all together.</span></code></pre>
<ul>
<li><code>group.head</code> Return the first element ; useful mostly for sorted case.</li>
<li><code>group.histogram</code></li>
<li><code>group.last</code> Return the last element; again, useful mostly for sorted case.</li>
</ul>
<p>More functions can be found at <a href="http://twitter.github.io/scalding/#com.twitter.scalding.StreamOperations"><code>StreamOperations</code></a> for stream-like functions (e.g take, drop) and [<code>FoldOperations</code>] (http://twitter.github.io/scalding/#com.twitter.scalding.FoldOperations) for fold/reduce-like functions (e.g. foldLeft).</p>
<h3 id="about-functions-on-multiple-fields-at-once"><a name="notes-tuples" href="#wiki-notes-tuples">About functions on multiple fields at once</a></h3>
<p>In many places in the scalding fields-based API can functions be applied to multiple fields at once. For example:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> britishBirds =
  birds.<span class="fu">map</span>(('weightInLbs, 'heightInFt) -&gt; ('weightInKg, 'heightInMeters)) {
    x : (Float, Float) =&gt;
    <span class="kw">val</span> (weightInLbs, heightInFt) = x
    (<span class="fl">0.454</span> * weightInLbs, <span class="fl">0.305</span> * heightInFt)
  }</code></pre>
<p>The parameter x is a tuple of size 2 which is consistent with the number of fields the function is expected to operate on. As an alternative you can also import FunctionImplicits._ and use a a regular function with multiple input arguments:</p>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> com.<span class="fu">twitter</span>.<span class="fu">scalding</span>.<span class="fu">FunctionImplicits</span>.<span class="fu">_</span>

<span class="kw">val</span> britishBirds =
  birds.<span class="fu">map</span>(('weightInLbs, 'heightInFt) -&gt; ('weightInKg, 'heightInMeters)) {
    (weightInLbs: Float, heightInFt: Float) =&gt;
    (<span class="fl">0.454</span> * weightInLbs, <span class="fl">0.305</span> * heightInFt)
  }</code></pre>

</div>

</div>
</div>

</body>
</html>

