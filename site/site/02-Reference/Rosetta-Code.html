<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
  <meta http-equiv="Content-Style-Type" content="text/css"></meta>
  <meta name="generator" content="pandoc"></meta>
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="http://localhost:8000/_src/css/bootstrap.min.css" type="text/css"></link>
  <link rel="stylesheet" href="http://localhost:8000/_src/css/custom.css" type="text/css"></link>
  <style type="text/css">
    table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
      margin: 0; padding: 0; vertical-align: baseline; border: none; }
    table.sourceCode { width: 100%; line-height: 100%; }
    td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
    td.sourceCode { padding-left: 5px; }
    code > span.kw { color: #007020; font-weight: bold; }
    code > span.dt { color: #902000; }
    code > span.dv { color: #40a070; }
    code > span.bn { color: #40a070; }
    code > span.fl { color: #40a070; }
    code > span.ch { color: #4070a0; }
    code > span.st { color: #4070a0; }
    code > span.co { color: #60a0b0; font-style: italic; }
    code > span.ot { color: #007020; }
    code > span.al { color: #ff0000; font-weight: bold; }
    code > span.fu { color: #06287e; }
    code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>

<div class="row">
    <div class="container">
        <div class="col-xs-4">
            <img id="logo" src="http://localhost:8000//_src/scalding.png">
        </div>
    </div>
</div>

<div class="container">
<div class="row">

<div class="col-xs-3" role="navigation" id="nav-left">
    
    <ul class="nav nav-pills nav-stacked"><li role="presentation"><a href="http://localhost:8000/site/.Foo.md.html">.Foo.md</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/11.html"></a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/Home.html">Home</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/_Sidebar.html">_Sidebar</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/hello.html">hello</a>
    </li>
    </ul>
    Tutorials > Beginner
    <ul class="nav nav-pills nav-stacked"><li role="presentation"><a href="http://localhost:8000/site/01-Tutorials/01-Beginner/01-Getting-Started.html">Getting Started</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/01-Tutorials/01-Beginner/02-Alice-in-Wonderland.html">Alice in Wonderland</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/01-Tutorials/01-Beginner/03-Intro-to-Scalding-Jobs.html">Intro to Scalding Jobs</a>
    </li>
    </ul>
    Tutorials > Intermediate
    <ul class="nav nav-pills nav-stacked"><li role="presentation"><a href="http://localhost:8000/site/01-Tutorials/02-Intermediate/Aggregation-using-Algebird-Aggregators.html">Aggregation using Algebird Aggregators</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/01-Tutorials/02-Intermediate/SQL-to-Scalding.html">SQL to Scalding</a>
    </li>
    </ul>
    Tutorials > Advanced
    <ul class="nav nav-pills nav-stacked"><li role="presentation"><a href="http://localhost:8000/site/01-Tutorials/03-Advanced/Building-bigger-platforms-with-scalding.html">Building bigger platforms with scalding</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/01-Tutorials/03-Advanced/Introduction-to-Matrix-Library.html">Introduction to Matrix Library</a>
    </li>
    </ul>
    Reference
    <ul class="nav nav-pills nav-stacked"><li role="presentation"><a href="http://localhost:8000/site/02-Reference/API-Reference.html">API Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Calling-Scalding-from-Inside-Your-Application.html">Calling Scalding from Inside Your Application</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Common-Exceptions-and-Possible-Reasons.html">Common Exceptions and Possible Reasons</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Frequently-asked-questions.html">Frequently asked questions</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Matrix-API-Reference.html">Matrix API Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Pig-to-Scalding.html">Pig to Scalding</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/REPL-Reference.html">REPL Reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Rosetta-Code.html">Rosetta Code</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Scald.rb.html">Scald.rb</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Scalding-Commons.html">Scalding Commons</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Scalding-HBase.html">Scalding HBase</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Scalding-REPL.html">Scalding REPL</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Scalding-Sources.html">Scalding Sources</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Type-safe-api-reference.html">Type safe api reference</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/Using-scalding-with-other-versions-of-scala.html">Using scalding with other versions of scala</a>
    </li>
    </ul>
    Reference > Fields API (Deprecated)
    <ul class="nav nav-pills nav-stacked"><li role="presentation"><a href="http://localhost:8000/site/02-Reference/01-Fields-API-(Deprecated)/Fields-API:-reduce-functions-of-GroupBuilder.html">Fields API: reduce functions of GroupBuilder</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/02-Reference/01-Fields-API-(Deprecated)/Fields-based-API-Reference.html">Fields based API Reference</a>
    </li>
    </ul>
    Other
    <ul class="nav nav-pills nav-stacked"><li role="presentation"><a href="http://localhost:8000/site/03-Other/Comparison-to-Scrunch-and-Scoobi.html">Comparison to Scrunch and Scoobi</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Field-rules.html">Field rules</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Powered-By.html">Powered By</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Run-in-Intellij-IDEA.html">Run in Intellij IDEA</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Scala-and-sbt-for-Homebrew-users.html">Scala and sbt for Homebrew users</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Scala-and-sbt-for-MacPorts-users.html">Scala and sbt for MacPorts users</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Scalding-on-amazon-elastic-mapreduce.html">Scalding on amazon elastic mapreduce</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Scalding-with-CDH3U2-in-a-Maven-project.html">Scalding with CDH3U2 in a Maven project</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Upgrading-to-0.9.0.html">Upgrading to 0.9.0</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Using-the-distributed-cache.html">Using the distributed cache</a>
    </li>
    <li role="presentation"><a href="http://localhost:8000/site/03-Other/Why-pack-unpack-and-not--toList[].html">Why pack unpack and not  toList[]</a>
    </li>
    </ul>
</div>

<div class="col-xs-9 text-body">

<div id="TOC">
<ul>
<li><a href="#word-count">Word Count</a></li>
<li><a href="#distributed-grep">Distributed Grep</a></li>
<li><a href="#inverted-index">Inverted Index</a></li>
</ul>
</div>
<p>A collection of MapReduce tasks translated (from Pig, Hive, MapReduce streaming, etc.) into Scalding. For fully runnable code, see the repository <a href="https://github.com/echen/rosetta-scone">here</a>.</p>
<h3 id="word-count">Word Count</h3>
<h4 id="hadoop-streaming-ruby">Hadoop Streaming (Ruby)</h4>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Emit (word, count) pairs.</span>
<span class="kw">def</span> mapper
  <span class="dt">STDIN</span>.each_line <span class="kw">do</span> |line|
    line.split.each <span class="kw">do</span> |word|
      puts [word, <span class="dv">1</span>].join(<span class="st">"\t"</span>)
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span>

<span class="co"># Aggregate all (word, count) pairs for a particular word.</span>
<span class="co">#</span>
<span class="co"># In Hadoop Streaming (unlike standard Hadoop), the reducer receives</span>
<span class="co"># rows from the mapper *one at a time*, though the rows are guaranteed</span>
<span class="co"># to be sorted by key (and every row associated to a particular key</span>
<span class="co"># will be sent to the same reducer).</span>
<span class="kw">def</span> reducer
  curr_word = <span class="dv">nil</span>
  curr_count = <span class="dv">0</span>
  <span class="dt">STDIN</span>.each_line <span class="kw">do</span> |line|
    word, count = line.strip.split(<span class="st">"\t"</span>)
    <span class="kw">if</span> word != curr_word
      puts [curr_word, curr_count].join(<span class="st">"\t"</span>)
      curr_word = word
      curr_count = <span class="dv">0</span>
    <span class="kw">end</span>
    curr_count += count.to_i
  <span class="kw">end</span>

  puts [curr_word, curr_count].join(<span class="st">"\t"</span>) <span class="kw">unless</span> curr_word.nil?
<span class="kw">end</span></code></pre>
<h4 id="hive">Hive</h4>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># tokenizer.py</span>
<span class="ch">import</span> sys

<span class="kw">for</span> line in sys.stdin:
  <span class="kw">for</span> word in line.split():
    <span class="dt">print</span> word</code></pre>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> tweets (text STRING);
LOAD <span class="kw">DATA</span> <span class="kw">LOCAL</span> INPATH <span class="st">'tweets.tsv'</span> OVERWRITE <span class="kw">INTO</span> <span class="kw">TABLE</span> tweets;

<span class="kw">SELECT</span> word, <span class="fu">COUNT</span>(*) <span class="kw">AS</span> <span class="fu">count</span>
<span class="kw">FROM</span> (
  <span class="kw">SELECT</span> TRANSFORM(text) <span class="kw">USING</span> <span class="st">'python tokenizer.py'</span> <span class="kw">AS</span> word
  <span class="kw">FROM</span> tweets
) t
<span class="kw">GROUP</span> <span class="kw">BY</span> word;</code></pre>
<h4 id="pig">Pig</h4>
<pre class="pig"><code>tweets = LOAD 'tweets.tsv' AS (text:chararray);
words = FOREACH tweets GENERATE FLATTEN(TOKENIZE(text)) AS word;
word_groups = GROUP words BY word;
word_counts = FOREACH word_groups GENERATE group AS word, COUNT(words) AS count;

STORE word_counts INTO 'word_counts.tsv';</code></pre>
<h4 id="cascalog-2.0">Cascalog 2.0</h4>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(cascalog.repl/bootstrap)

(?<- (hfs-textline <span class="st">"word_counts.tsv"</span>) [?word ?count]
     ((hfs-textline <span class="st">"tweets.tsv"</span>) ?text)
     ((mapcatfn [text] (.split text <span class="st">"</span>\\<span class="st">s+"</span>)) ?text :> ?word)
     (c/count ?count)))</code></pre>
<h4 id="scalding">Scalding</h4>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> com.<span class="fu">twitter</span>.<span class="fu">scalding</span>.<span class="fu">_</span>

<span class="kw">class</span> <span class="fu">ScaldingTestJob</span>(args: Args) <span class="kw">extends</span> <span class="fu">Job</span>(args) {
  <span class="fu">Tsv</span>(<span class="st">"tweets.tsv"</span>, 'text)
    .<span class="fu">flatMap</span>('text -> 'word)[String, String](_.<span class="fu">split</span>(<span class="st">"</span><span class="ch">\\</span><span class="st">s+"</span>))
    .<span class="fu">groupBy</span>('word)(_.<span class="fu">size</span>)
    .<span class="fu">write</span>(<span class="fu">Tsv</span>(<span class="st">"word_counts.tsv"</span>))
}</code></pre>
<h3 id="distributed-grep">Distributed Grep</h3>
<h4 id="hadoop-streaming-ruby-1">Hadoop Streaming (Ruby)</h4>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">PATTERN</span> = <span class="ot">/.*hello.*/</span>

<span class="co"># Emit words that match the pattern.</span>
<span class="kw">def</span> mapper
  <span class="dt">STDIN</span>.each_line <span class="kw">do</span> |line|
    puts line <span class="kw">if</span> line =~ <span class="dt">PATTERN</span>
  <span class="kw">end</span>
<span class="kw">end</span>

<span class="co"># Identity reducer.</span>
<span class="kw">def</span> reducer
  <span class="dt">STDIN</span>.each_line <span class="kw">do</span> |line|
    puts line
  <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<h4 id="pig-1">Pig</h4>
<pre class="pig"><code>%declare PATTERN '.*hello.*';

tweets = LOAD 'tweets.tsv' AS (text:chararray);
results = FILTER tweets BY (text MATCHES '$PATTERN');</code></pre>
<h4 id="cascalog">Cascalog</h4>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> pattern </span><span class="st">#".*hello.*"</span>)

(deffilterop matches-pattern? [text pattern]
  (<span class="kw">re-matches</span> pattern text))

(<span class="kw">defn</span><span class="fu"> distributed-grep </span>[input pattern]
  (<- [?textline]
      (input ?textline)
      (matches-pattern? ?textline pattern)))

(?- (stdout) (distributed-grep (hfs-textline <span class="st">"tweets.tsv"</span>) pattern))</code></pre>
<h4 id="scalding-1">Scalding</h4>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> Pattern = <span class="st">".*hello.*"</span>.<span class="fu">r</span>

TypedTsv[String](<span class="st">"tweets.tsv"</span>).<span class="fu">filter</span> { _.<span class="fu">matches</span>(Pattern) }</code></pre>
<h3 id="inverted-index">Inverted Index</h3>
<h4 id="hadoop-streaming-ruby-2">Hadoop Streaming (Ruby)</h4>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Emit (word, tweet_id) pairs.</span>
<span class="kw">def</span> mapper
  <span class="dt">STDIN</span>.each_line <span class="kw">do</span> |line|
    tweet_id, text = line.strip.split(<span class="st">"\t"</span>)
    text.split.each <span class="kw">do</span> |word|
      puts [word, tweet_id].join(<span class="st">"\t"</span>)
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span>

<span class="co"># Aggregate all (word, tweet_id) pairs for a particular word.</span>
<span class="co">#</span>
<span class="co"># In Hadoop Streaming (unlike standard Hadoop), the reducer receives</span>
<span class="co"># rows from the mapper *one at a time*, though the rows are guaranteed</span>
<span class="co"># to be sorted by key (and every row associated to a particular key</span>
<span class="co"># will be sent to the same reducer).</span>
<span class="kw">def</span> reducer
  curr_word = <span class="dv">nil</span>
  curr_inv_index = []
  <span class="dt">STDIN</span>.each_line <span class="kw">do</span> |line|
    word, tweet_id = line.strip.split(<span class="st">"\t"</span>)
    <span class="kw">if</span> word != curr_word
      <span class="co"># New key.</span>
      puts [curr_word, curr_inv_index.join(<span class="st">","</span>)].join(<span class="st">"\t"</span>)
      curr_word = word
      curr_inv_index = []
    <span class="kw">end</span>
    curr_inv_index << tweet_id
  <span class="kw">end</span>

  <span class="kw">unless</span> curr_word.nil?
    puts [curr_word, curr_inv_index.join(<span class="st">", "</span>)].join(<span class="st">"\t"</span>)
  <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<h4 id="pig-2">Pig</h4>
<pre class="pig"><code>tweets = LOAD 'tweets.tsv' AS (tweet_id:int, text:chararray);

words = FOREACH tweets GENERATE tweet_id, FLATTEN(TOKENIZE(text)) AS word;
word_groups = GROUP words BY word;
inverted_index = FOREACH word_groups GENERATE group AS word, words.tweet_id;</code></pre>
<h4 id="cascalog-1">Cascalog</h4>
<pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="co">;; define the data</span>
(<span class="kw">def</span><span class="fu"> index </span>[
  [<span class="dv">0</span> <span class="st">"Hello World"</span>]
  [<span class="dv">101</span> <span class="st">"The quick brown fox jumps over the lazy dog"</span>]
  [<span class="dv">42</span> <span class="st">"Answer to the Ultimate Question of Life, the Universe, and Everything"</span>]
])

<span class="co">;; the tokenize function</span>
(defmapcatop tokenize [text]
  (<span class="kw">seq</span> (.split text <span class="st">"</span>\\<span class="st">s+"</span>)))

<span class="co">;; ensure inverted index is distinct per word</span>
(defbufferop distinct-vals [tuples]
  (<span class="kw">list</span> (<span class="kw">set</span> (<span class="kw">map</span> <span class="kw">first</span> tuples))))

<span class="co">;; run the query on data</span>
(?<- (stdout) [?word ?ids]
        (<span class="kw">index</span> ?id ?text)
        (tokenize ?text :> ?word)
        (distinct-vals ?id :> ?ids))</code></pre>
<h4 id="scalding-2">Scalding</h4>
<pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> invertedIndex =
  TypedTsv[Int,String](<span class="st">"tweets.tsv"</span>)
  .<span class="fu">flatMap</span> { <span class="kw">case</span> (tweetId, text) => text.<span class="fu">split</span>(<span class="st">"</span><span class="ch">\\</span><span class="st">s+"</span>).<span class="fu">map</span>((_, tweetId)) }
  .<span class="fu">group</span></code></pre>

</div>

</div>
</div>

</body>
</html>
